1.过滤器：实现了javax.servlet.Filter接口，随web应用启动而启动的，只初始化一次，以后就可以拦截相关请求，只有当你的web应用停止或重新部署的时候才销毁。在web.xml中配置
  用途：字符编码，业务逻辑判断（用户是否已经登陆，有无权限访问该页面等等工作。）
  原理：在web.xml文件配置好要拦截的客户端请求，它都会帮你拦截到请求。此时可对请求或响应统一设置编码，简化操作等。
2.监听器：实现了javax.servlet.ServletContextListener 接口，随web应用的启动而启动，只初始化一次，随web应用的停止而销毁。
  用途：初始化，设置参数或固定对象等，可在事情发生前，发生后做一些必要的处理。在web.xml中配置。销毁session
3.拦截器：面向切面编程，基于Java反射机制。在struts.xml中配置
4.过滤器、拦截器的区别
a.拦截器基于Java反射机制，而过滤器是基于函数回调
b.拦截器不依赖于servlet容器，而过滤器依赖于servlet容器
c.拦截器只能对action请求起作用，而过滤器则可以对几乎所有请求起作用
d.拦截器可以访问action上下文，值栈里的对象，而过滤器不能
e.在action生命周期中，拦截器可以多次调用，而过滤器只能在容器初始化时被调用一次。
f.过滤器：取己所需，略其不要。拦截器：针对你不要的东西进行拦截。
g.过滤器，是在Java web中，你传入request，response提前过滤掉一些信息。或者提前设置一些参数，然后在传入servlet或者struts2的action进行业务逻辑，
  比如过滤掉非法url（不是login.do的地址请求，如果用户没有登录都过滤掉），或者传入servlet或者struts2的action前统一设置字符集，或者除掉一些非法字符。
h.拦截器，是在面向切面编程的就是在你的service或者一个方法，前调用一个方法，或者在方法调用一个方法比如动态代理就是拦截器的简单实现，
  在你调用方法前打印出字符串（或者做其他业务逻辑的操作），也可以在你调用方法后打印出字符串，甚至在你抛出异常的时候做业务逻辑的操作。
i.执行顺序：过滤前-拦截前-action处理-拦截后-过滤后。个人认为过滤是一个横向的过程，首先把客户端提交的内容进行过滤（例如未登陆用户不能访问内部页面的处理）；
  过滤通过后，拦截器将检查用户提交数据的验证，做一些前期的数据处理，接着把处理后的数据发给对应的action；action处理完成返回后，拦截器还可以做其他过程，再向上返回到过滤器的后续操作。
  
参考网址：http://blog.csdn.net/xyw591238/article/details/51943485
